# Task

## 1、任务调度机制

任务的主要机制由`tskTaskControlBlock`进行控制。

![image-20230731102814906](D:\MarkdowPad2_md\随手记\images\image-20230731102814906.png)

相关参数列表注释：

```tex
pxTopOfStack:创建任务栈的栈顶指针;
xStateListItem:状态链表节点;
xEventListItem:事件列表节点；
uxPrioroty:任务优先级;
pxStack:指向栈开始地址指针；
pcTaskName:任务名称；
```

### 1.1、创建任务

当创建任务

```c
xTaskCreate( Task1Funcation, "Task1", 100, "Task1", 1, &xHandleTask1);
```

调用时，将相关参数传入`tskTaskControlBlock`结构体中，对于`Task1Funcation`，和栈的大小。

- 任务函数
  - `Task1Funcation`的函数指针保存在**PC寄存器**，函数的形参（param）保存在**R0寄存器**（因为只有一个参数）；
  - 任务开始后，任务暂停需要保存现场，那时将`Task1Funcation`，和`param`，保存到**PC寄存器，R0寄存器**；

![image-20230731134416064](D:\MarkdowPad2_md\随手记\images\image-20230731134416064.png)



![image-20230731134542159](D:\MarkdowPad2_md\随手记\images\image-20230731134542159.png)

- 任务栈
  - 栈的大小根据**函数的局部变量和函数的调用深度**进行分配；
  - 栈本身是一段连续空闲的内存，在FreeRTOS中，默认分配了`17 * 1024`的大小；
  - 栈的起始地址保存在`tskTaskControlBlock`中的`pxStack`；



![image-20230731122334457](D:\MarkdowPad2_md\随手记\images\image-20230731122334457.png)

### 1.2、优先级及状态

* 优先级不同
  * 高优先级的任务，优先执行，可以抢占低优先级的任务
  * 高优先级的任务不停止，低优先级的任务永远无法执行
  * 同等优先级的任务，轮流执行：时间片轮转
* 状态
  * 运行态：running
  * 就绪态：ready
  * 阻塞：blocked，等待某件事(时间、事件)
  * 暂停：suspend，休息去了
* 怎么管理？
  * 怎么取出要运行的任务？
    * 找到最高优先级的运行态、就绪态任务，运行它
    * 如果大家平级，轮流执行：排队，链表前面的先运行，运行1个tick后乖乖地去链表尾部排队

### 1.3、任务链表

当创建完任务后，内核将任务放入任务链表。任务链表根据任务优先级进行分类。

![image-20230731141358740](D:\MarkdowPad2_md\随手记\images\image-20230731141358740.png)



![image-20230731141425758](D:\MarkdowPad2_md\随手记\images\image-20230731141425758.png)



![image-20230731141448014](D:\MarkdowPad2_md\随手记\images\image-20230731141448014.png)

创建就绪链表数组进行存储，根据优先级进行任务分类，将不同优先级任务区分，相同优先级归类。

![image-20230731141602689](D:\MarkdowPad2_md\随手记\images\image-20230731141602689.png)



### 1.4、调度管理

TICK中断函数进行管理。

TICK中断函数有两个功能：

- 取出下一个task；
- 切换task：
  - 保存当前task；
  - 恢复新task；

## 2、任务状态切换

任务属性：

- 高优先级任务永远先执行；
- 最低优先级的中断，优先级也比最高优先级任务高；

![image-20230731144543987](D:\MarkdowPad2_md\随手记\images\image-20230731144543987.png)

任务切换：

1. 创建任务后将任务放入相应优先级的`pxReadyTasksLists`链表；
2. 当任务释放了cpu后或者调用`vTaskDelay()`函数后，将任务移至`pxDelaydTaskList`链表；
3. 当任务需要占用CPU或者延时时间到了，内核将任务从`pxDelaydTaskList`重新移至`pxReadyTasksLists`；
4. 调度，运行任务；

## 3、 通过链表深入理解调度机制

* 可抢占：高优先级的任务先运行
* 时间片轮转：同优先级的任务轮流执行
* 空闲任务礼让：如果有同是优先级0的其他就绪任务，空闲任务主动放弃一次运行机会

### 3.1、空闲任务（IDLE）

```c
vTaskStartScheduler();//启动调度器，创建idle任务
```

![image-20230731155144073](D:\MarkdowPad2_md\随手记\images\image-20230731155144073.png)

**特性：**

- 空闲任务优先级为0：它不能阻碍用户任务运行；
- 空闲任务要么处于就绪态，要么处于运行态，永远不会阻塞；

空闲任务的优先级为**0**，这意味着一旦某个用户的任务变为就绪态，那么空闲任务马上被切换出去，让这个用户任务运行。在这种情况下，我们说用户任务”抢占”(pre-empt)了空闲任务，这是由调度器实现的。

要注意的是：如果使用`vTaskDelete()`来删除任务，那么你就要确保空闲任务有机会执行，否则就无法释放被删除任务的内存。

### 3.2、钩子函数（Idle Task Hook Functions）

空闲任务的钩子函数(Idle Task Hook Functions)，空闲任务的循环每执行一次，就会调用一次钩子函数。

**钩子函数的作用有这些：**

- 执行一些低优先级的、后台的、需要连续执行的函数；
- 测量系统的空闲时间：空闲任务能被执行就意味着所有的高优先级任务都停止了，所以测量空闲任务占据的时间，就可以算出处理器占用率；
- 让系统进入省电模式：空闲任务能被执行就意味着没有重要的事情要做，当然可以进入省电模式了。

**空闲任务的钩子函数的限制：**

- 不能导致空闲任务进入阻塞状态、暂停状态
- 如果你会使用`vTaskDelete()`来删除任务，那么钩子函数要非常高效地执行。如果空闲任务移植卡在钩子函数里的话，它就无法释放内存。
